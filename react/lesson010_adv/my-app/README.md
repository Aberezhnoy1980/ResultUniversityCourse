# Рендер react не есть рендер браузера!

* Рендер — это процесс преобразования ресурсов, описанных в проекте какого-то продукта в сам продукт.
* Когда React компонент рендерится, он создает свое виртуальное представление в виде древовидной структуры. В дальнейшем оно используется для создания реального соответствующего представления на экране пользователя.
* Основные случаи, при которых происходит рендер компонента:
инициализация приложения;
изменение данных компонента (состояние, пропсы, данные Контекста).
* Алгоритм согласования (reconciliation) помогает React оптимизировать обновление пользовательского интерфейса, предотвращая лишние перерисовки компонентов и обеспечивая более эффективное использование ресурсов браузера.
* Основные шаги при рендере:
	* **Создание обновленного виртуального представления** (иногда называют Virtual DOM). Когда данные компонента изменяются, React создает его новое виртуальное представление.
	* **Сравнение двух виртуальных представлений и выявление различий.** React сравнивает старое и новое виртуальные DOM, чтобы определить, какие элементы были изменены, добавлены или удалены.
	* **Минимизация изменений.** React стремится найти самый оптимальный путь обновления реального DOM, то есть выполнить в нем как можно меньше изменений (в том числе здесь помогает проп key).
	* **Обновление реального DOM.** После определения различий, React при необходимости применяет найденные изменения к реальному DOM, чтобы отобразить обновленный контент на экране.

## useCallback

* <em style="color: #EB5757">useCallback()</em>, <em style="color: #EB5757">useMemo()</em> и <em style="color: #EB5757">memo()</em> используются для ручной оптимизации рендера компонентов.
* <em style="color: #EB5757">useCallback()</em> позволяет сохранить ссылку на коллбек-функцию, пересоздавая её только при изменении зависимостей. В зависимости следует указывать внешние переменные, используемые в коллбеке, которые могут измениться.
* Сет-функцию из хука <em style="color: #EB5757">useState()</em> не нужно указывать в зависимостях (относится как к useCallback(), так и к useEffect() и другим хукам).
* Не нужно использовать <em style="color: #EB5757">useCallback()</em> просто для того, чтобы функция не “пересоздавалась” между рендерами. Это бесполезно и ухудшает читаемость кода.

## useMemo

* <em style="color: #EB5757">memo()</em> позволяет пропустить повторный рендер компонента, если его пропсы не изменились.
* Чтобы получить мемоизированную версию компонента, необходимо обернуть его в <em style="color: #EB5757">memo()</em>.
* Оптимизация с помощью <em style="color: #EB5757">memo()</em> полезна, когда компонент часто повторно рендерится с одними и теми же пропсами, а его логика повторного рендера требует больших затрат. Если нет заметной задержки при повторном рендере компонента, в <em style="color: #EB5757">memo()</em> нет необходимости.
* Имейте в виду, что <em style="color: #EB5757">memo()</em> бесполезен, если пропсы, передаваемые компоненту, всегда разные (например, если передается объект или простая функция, определенная во время рендера). Вот почему вместе с <em style="color: #EB5757">memo()</em> часто используются <em style="color: #EB5757">useMemo()</em> и <em style="color: #EB5757">useCallback()</em>.
* Использование <em style="color: #EB5757">useCallback()</em> полезно в случаях, когда:
	* указанная коллбэк-фукнция позже передается через пропсы компоненту, обернутому в <em style="color: #EB5757">memo()</em>;
	* указанная коллбэк-фукнция позже используется как зависимость в другом хуке (например, указана в зависимостях <em style="color: #EB5757">useEffect()</em>).

## Ненужное состояние

* Не нужно создавать внутреннее состояние через <em style="color: #EB5757">useState(</em>) для переменной, которая вычисляется из других значений, уже находящихся во внутреннем состоянии.

## useMemo

* Мемоизация — это способность функции сохранять результаты выполнения для заданных параметров и использовать их при повторных вызовах функции с теми же параметрами.
* <em style="color: #EB5757">useMemo()</em> позволяет кэшировать (мемоизировать) результат вычислений между повторными рендерами. Используется для оптимизации производительности.
* Использование <em style="color: #EB5757">useMemo()</em> полезно в случаях, когда:
	* вычисления, которые помещаются в <em style="color: #EB5757">useMemo()</em>, заметно медленные, а зависимости редко меняются;
	* результат <em style="color: #EB5757">useMemo()</em> передается через пропсы компоненту, обернутому в <em style="color: #EB5757">memo()</em> (избежим повторного рендера, если значение не изменилось);
	* результат <em style="color: #EB5757">useMemo()</em> позже используется как зависимость в другом хуке (например, указан в зависимостях <em style="color: #EB5757">useEffect()</em>).

## Классовык компоненты

* Компоненты в React можно создать двумя способами: с помощью функций и с помощью классов.
* Для создания классового компонента используется обыкновенный JavaScript-класс, который необходимо наследовать от базового класса Component, предоставляемого React. Также можно наследовать от PureComponent, что будет схоже по поведению с функциональным компонентом, обернутым в memo().
* Для классовых компонентов определен список методов жизненного цикла, которые могут быть переопределены в компоненте, позволяя выполнять определенные действия на различных этапах существования компонента.
* Классовые компоненты по прежнему поддерживаются React, но их не рекомендуется использовать в новом коде.
* По умолчанию, если приложение выдает ошибку во время рендера, React удалит пользовательский интерфейс с экрана. Чтобы предотвратить это, можно заключить часть пользовательского интерфейса в ErrorBoundary. Это специальный компонент, который позволяет отображать резервный пользовательский интерфейс вместо той части, в которой произошел сбой (например, можно отобразить сообщение об ошибке).
* В настоящее время нет способа написать ErrorBoundary в виде функционального компонента. Можно написать его один раз и использовать во всем приложении или воспользоваться готовым пакетом “react-error-boundary”.

## Render props and HOC

* Компонент высшего порядка (Higher-Order Component или HOC) — это продвинутая техника в React, которая применяется для повторного использования логики компонентов. HOC представляет собой функцию, которая принимает компонент и возвращает новый компонент с расширенными свойствами и функциональностью.
* HOC позволяет добавить дополнительные возможности или логику к компонентам без необходимости дублирования кода. Полезен для добавления сайд-эффектов или общей функциональности к компонентам.
* С помощью HOC можно массово добавить одну и ту же функциональность для разных компонентов.
* HOC можно заменить созданием нового компонента, который принимает исходный компонент и применяет к нему нужные изменения, либо использовать паттерн Render Props.
